后台运行&

1.基础语法：在命令末尾加&，即可让程序脱离当前终端会话，在后台运行，按下回车终端显示两个信息：作业号，用于后续管理这个后台进程，进程ID，系统级唯一识别这个进程

2.和前台运行的核心区别：将子进程放入后台作业组，不再阻塞等待其结束

前台运行：父进程 “盯着” 子进程，终端被占用，直到子进程结束；

后台运行：父进程 “放手” 但不 “放弃”，终端可继续用，父进程仍能管理子进程。

3. 输出重定向（必看！新手最易踩坑）

后台运行的程序默认仍会将 `stdout`/`stderr`（标准输出 / 错误）输出到当前终端，会干扰你的终端操作，因此**必须重定向输出**：

```c++
# 推荐写法：将标准输出和错误都重定向到文件，后台运行
./my_program > output.log 2>&1 &
```

`> output.log`：将标准输出（cout/printf）写入 `output.log`；

`2>&1`：将标准错误（cerr/perror）重定向到和标准输出相同的文件；

最后 `&`：后台运行。

4. 会话退出后进程是否存活？

- 仅加 `&` 的后台进程，属于当前终端会话的子进程；

- 若关闭终端 / 退出 SSH 连接，进程会被系统终止（收到 `SIGHUP` 信号）。

- ```c++
  # 永久后台运行：即使关闭终端，进程仍存活
  nohup ./my_program > output.log 2>&1 &
  ```

- `nohup`：全称 `no hang up`，表示 “不挂断”，忽略 `SIGHUP` 信号；

  若不指定输出文件，默认会生成 `nohup.out` 存储输出。

  5.查看后台进程

  ```c++
  # 方法1：查看当前终端的后台作业（显示作业号+状态）
  jobs
  
  # 输出示例
  [1]+  Running                 ./my_program > output.log 2>&1 &
  
  # 方法2：查看所有进程（通过进程名/PID筛选）
  ps -ef | grep my_program
  # 或更简洁的方式
  pgrep my_program
  ```

  6.将后台进程调回前台 	调回前台后，可按 `Ctrl+C` 终止进程。

  ```c++
  # fg + 作业号（jobs命令看到的[1]）
  fg 1
  ```

  7.终止后台进程

  ```c++
  # 方法1：通过作业号终止
  kill %1  # %+作业号，如%1对应jobs中的[1]
  
  # 方法2：通过PID终止（最通用）
  kill 12345  # 12345是进程ID
  
  # 强制终止（进程无响应时）
  kill -9 12345
  ```

  8.后台程序需手动刷新输出缓冲区，避免输入依赖终端