管道

本质：把前一个命令的输出直接作为后一个命令的输入，实现多个命令的串联执行

1.分类：

**匿名管道**

本质**：内核在内存中创建的一个临时 “单向字节流缓冲区”，没有磁盘文件对应的路径，仅能用于**具有亲缘关系的进程**（如父子进程、兄弟进程）之间的通信。

- **Shell 中的体现**：我们日常使用的 `|` 符号就是匿名管道，它会自动创建、使用后销毁，用户无法感知其存在。

- **特点**：

  - 单向通信：数据只能从**写端**流向**读端**，不能反向。
  - 阻塞特性：若读端未读取数据，写端写入会阻塞；若写端无数据写入，读端读取会阻塞。
  - 生命周期：随进程退出而销毁。

  

**命名管道**

- **本质**：在磁盘上创建的一个**特殊文件**（类型标识为 `p`），有实际的文件路径，可用于**任意两个无关进程**之间的通信。
- **创建方式**：通过命令 `mkfifo 管道名` 或 C/C++ 函数 `mkfifo()` 创建。
- **特点**：
  - 有文件名和路径，可通过文件操作函数（`open()`/`read()`/`write()`）访问。
  - 遵循 “先进先出（FIFO）” 原则，数据写入顺序与读取顺序一致。
  - 仅存储数据于内存，不占用磁盘空间，数据读取后即被删除

2.匿名管道的使用：

语法：命令1|命令2

|是管道符，用于连接前后两个命令

命令1的输出会被重定向到管道的写端，命令2的输入会从管道的读端读取数据

管道默认只传递标准输出，标准错误不会被传递，若需要传递则需要手动重定向如2>&1

3.匿名管道和命名管道的区别

| 特点     | 匿名管道                 | 命名管道               |
| -------- | ------------------------ | ---------------------- |
| 存在形式 | 内存中临时缓冲区，无路径 | 磁盘上特殊文件，有路径 |
| 通信对象 | 仅限亲缘关系进程         | 任意无关进程           |
| 创建方式 | pipe()函数               | mkfifo()函数           |
| 生命周期 | 随进程退出销毁           | 随文件删除销毁（rm)    |

4.管道的核心特点与限制

单向性：数据只能单项流动，若需双向通信需创建两个管道

字节流传输：管道传输的是无格式的字节流，读写双方需约定数据格式

缓冲区大小：匿名管道的缓冲区大小由内核决定，通常为4KB或8KB，若写入数据超过缓冲区大小，写端会阻塞

不支持lseek();

5.实现自己shell中的管道功能底层逻辑：

核心API：

| 函数                          | 功能             |
| ----------------------------- | ---------------- |
| int pipe(int pipefd[2])       | 创建匿名管道     |
| int dup2(int oldfd,int newfd) | 文件描述符重定向 |
| pid_t fork()                  | 创建子进程       |

**创建匿名管道**：调用 `pipe(int pipefd[2])` 函数，该函数会返回两个文件描述符：

- `pipefd[1]`：管道的**写端**，用于写入数据。
- `pipefd[0]`：管道的**读端**，用于读取数据。

**创建子进程**：通过 `fork()` 创建两个子进程（分别执行 command1 和 command2）。

**重定向文件描述符**：

- 对于执行 `command1` 的子进程：

  - 关闭管道的读端 `pipefd[0]`（只写不读）。
  - 调用 `dup2(pipefd[1], STDOUT_FILENO)`，将**标准输出重定向到管道写端**。
  - 执行 `command1`，其输出会写入管道。

  

- 对于执行 `command2` 的子进程：

  - 关闭管道的写端 `pipefd[1]`（只读不写）。
  - 调用 `dup2(pipefd[0], STDIN_FILENO)`，将**标准输入重定向到管道读端**。
  - 执行 `command2`，从管道读取 `command1` 的输出作为输入。

  

**父进程回收资源**：

- 关闭父进程中的 `pipefd[0]` 和 `pipefd[1]`（父进程不参与数据读写）。
- 调用 `waitpid()` 等待子进程退出，回收僵尸进程。

6.实现自己shell中管道功能需要注意：

**管道两端的关闭时机**：必须及时关闭不需要的管道端，否则会导致读端阻塞（例如，若写端未全部关闭，读端会一直等待数据）。

**多命令管道的处理**：若支持 `cmd1|cmd2|cmd3` 这样的多管道，需循环创建管道和子进程，依次重定向。

**与重定向的优先级**：管道的优先级高于输入输出重定向（`>`/`<`/`>>`），需注意处理顺序

7.为什么管道命令是「并行执行」的？

每个管道命令都在独立的子进程中运行，子进程由父进程 fork 后，**互不阻塞、并行执行**，这也是 Linux 管道的核心特性，比如`find / | grep txt`，`find`和`grep`是同时运行的，`find`查到数据后立即写入管道，`grep`立即读取并过滤，效率极高。

8.管道的「阻塞机制」是什么？

- 管道的读端`pipefd[0]`读取数据时，如果管道为空，**读端会阻塞**，直到有数据写入 / 所有写端被关闭；

- 管道的写端`pipefd[1]`写入数据时，如果管道满了，**写端会阻塞**，直到有数据被读取；

 这也是为什么必须关闭无用的管道描述符：如果写端不关闭，读端会一直阻塞等待数据，永远无法退出。

9.为什么`execvp`执行后，管道的映射依然有效？

`execvp`会替换子进程的地址空间，但**不会关闭任何打开的文件描述符**，包括`STDIN_FILENO/STDOUT_FILENO`，所以之前通过`dup2`完成的管道 / 文件重定向映射，在`execvp`执行后依然有效，命令的输入输出会自动走映射后的通道，这是重定向能生效的核心原因。

10.管道和文件重定向的优先级？

**管道重定向 先执行，文件重定向 后执行**，优先级：`文件重定向 > 管道重定向`
