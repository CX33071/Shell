1.什么是顺序表？用一段地址连续的物理存储单元，依次存储线性表中的数据元素的存储结构，顺序表底层就是数组。
2.特点：地址连续+随机访问效率高（第i个元素的地址=顺序表首地址+i*单个元素占用字节数）访问时间复杂度为O(1)
3.分为静态顺序表和动态顺序表
    静态顺序表
    定义：存储空间大小固定，在创建时就指定容量，一旦存满就无法再添加新元素。
    底层实现：固定长度的数组（比如 C 语言的int arr[10]，Java 的int[] arr = new int[10]）
    缺点：空间浪费 / 空间不足二选一：容量开小了存不下数据，容量开大了用不完就浪费内存 → 实用性差
    动态顺序表
    定义：存储空间大小可以动态扩容，创建时指定初始容量，存满后会自动申请一块更大的连续内存空间，把原数据拷贝过去，再释放原空间，扩容后继续支持新增元素。
    底层实现：动态数组（比如 Java 的ArrayList、Python 的list、C++ 的vector）
    扩容规则：主流编程语言的扩容比例都是 1.5 倍 / 2 倍（比如 Java ArrayList 默认初始容量 10，满了就扩容为 15，再满扩容为 22...）
4.顺序表的核心操作（增 / 删 / 改 / 查）+ 时间复杂度
顺序表的查、改效率极高，增、删效率极低，核心原因：顺序表的元素地址连续，增删元素会触发「元素移动」。
所有操作以下标从 0 开始为例，核心操作 + 时间复杂度如下：
     查找 / 修改元素（核心高效操作）
    按「下标」查找 / 修改：直接通过下标定位，一步到位 → 时间复杂度 O(1)
    按「元素值」查找：需要从头遍历到尾，最坏要遍历全部元素 → 时间复杂度 O(n)
     插入元素（核心低效操作）
    插入分为「尾部插入」和「中间 / 头部插入」，效率天差地别：
    尾部插入：直接把元素放到最后一个位置，无需移动任何元素 → 时间复杂度 O(1)
    中间 / 头部插入：插入位置之后的所有元素都要向后移动一位，腾出位置放新元素
        最坏情况（头部插入）：移动全部 n 个元素 → 时间复杂度 O(n)
        平均情况：移动 n/2 个元素 → 时间复杂度 O(n)
     删除元素（核心低效操作）
和插入逻辑对称，删除分为「尾部删除」和「中间 / 头部删除」：
    尾部删除：直接删掉最后一个元素，无需移动任何元素 → 时间复杂度 O(1)
    中间 / 头部删除：删除位置之后的所有元素都要向前移动一位，填补空缺
        最坏情况（头部删除）：移动全部 n 个元素 → 时间复杂度 O(n)
        平均情况：移动 n/2 个元素 → 时间复杂度 O(n)
5.C++ 中静态顺序表用栈区固定大小数组实现，动态顺序表用堆区动态数组（new/delete） 实现；
动态顺序表扩容规则：满容量后，申请2 倍原容量的新内存（C++ 标准库vector的扩容规则），将原数据拷贝后释放旧内存，效率最优